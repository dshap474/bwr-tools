#!/usr/bin/env npx ts-node

// ┌────────────────────────────────────────────────────────────────────────────────────┐
// │ BWR Plot Generation Test                                                            │
// └────────────────────────────────────────────────────────────────────────────────────┘

import { DataFrame } from '../packages/tools/plots/data/src';
import { ScatterChart, BarChart } from '../packages/tools/plots/charts/src';
import fetch from 'node-fetch';
import * as fs from 'fs';
import * as path from 'path';

// Dummy test data encoded directly in the file
const TEST_DATA = {
  // Simple linear relationship with some noise
  simple: {
    x: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    y: [2.1, 4.3, 5.8, 8.2, 10.1, 11.9, 14.2, 16.1, 17.8, 20.3],
    category: ['A', 'B', 'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B']
  },

  // Financial-like time series data
  financial: {
    date: [
      '2024-01-01', '2024-01-02', '2024-01-03', '2024-01-04', '2024-01-05',
      '2024-01-06', '2024-01-07', '2024-01-08', '2024-01-09', '2024-01-10'
    ],
    price: [100.0, 102.5, 98.3, 105.7, 108.2, 103.9, 112.4, 109.8, 115.3, 118.7],
    volume: [1500000, 1800000, 2100000, 1700000, 1900000, 1600000, 2200000, 1850000, 2000000, 1750000]
  },

  // Correlated data with scaling
  correlated: {
    x: [10, 25, 40, 55, 70, 85, 100, 115, 130, 145],
    y: [1200, 2800, 4100, 5900, 7300, 8500, 10200, 11800, 13100, 14700],
    size: [5, 8, 12, 6, 15, 9, 11, 7, 13, 10]
  },

  // Bar chart test data
  categories: {
    category: ['Tech', 'Finance', 'Healthcare', 'Energy', 'Consumer', 'Utilities'],
    revenue: [45000, 38000, 29000, 52000, 33000, 18000],
    profit: [8500, 7200, 5800, 9800, 6100, 3200]
  },

  // Sorted bar chart data
  performance: {
    company: ['Apple', 'Microsoft', 'Amazon', 'Google', 'Tesla', 'Meta', 'Netflix'],
    market_cap: [2800, 2200, 1500, 1400, 800, 600, 180],
    growth: [8.2, 12.5, -2.1, 6.7, 45.2, -15.8, 22.1]
  }
};

interface TestResult {
  testName: string;
  success: boolean;
  error?: string;
  configGenerated: boolean;
  pythonImageSaved: boolean;
  typescriptConfigSaved: boolean;
  imagePath?: string;
  configPath?: string;
}

class BWRPlotTester {
  private outputDir: string;
  private serverUrl: string;

  constructor() {
    this.outputDir = path.join(__dirname, 'test_plots');
    this.serverUrl = 'http://localhost:5001';
    
    // Ensure output directory exists
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
    }
  }

  /**
   * Test TypeScript bar chart generation
   */
  async testTypeScriptBarChart(testName: string, data: any, chartOptions: any = {}): Promise<TestResult> {
    console.log(`\n📊 Testing TypeScript bar chart: ${testName}`);

    const result: TestResult = {
      testName: testName + '_bar',
      success: false,
      configGenerated: false,
      pythonImageSaved: false,
      typescriptConfigSaved: false
    };

    try {
      // Create DataFrame
      const df = new DataFrame(data);
      console.log(`   📊 DataFrame created: ${df.shape[0]} rows × ${df.shape[1]} columns`);

      // Determine chart configuration for bar chart
      const columns = df.columns;
      const xColumn = this.detectCategoryColumn(columns, data);
      const yColumns = this.detectValueColumns(columns, data, xColumn);
      
      console.log(`   📈 Bar chart config: x='${xColumn}', y=[${yColumns.join(', ')}]`);

      // Create bar chart
      const chart = new BarChart({
        dataframe: df,
        xColumn,
        yColumns
      }, {
        title: `BWR Bar Chart - ${testName}`,
        subtitle: 'Generated by TypeScript Implementation',
        ...chartOptions
      });

      // Validate chart
      if (!chart.isValid()) {
        throw new Error(`Chart validation failed: ${chart.getValidationErrors().join(', ')}`);
      }

      // Generate Plotly configuration
      const plotlyConfig = chart.render();
      result.configGenerated = true;

      console.log(`   ✅ Plotly config generated: ${JSON.stringify(plotlyConfig).length} characters`);

      // Save TypeScript configuration
      const configPath = path.join(this.outputDir, `${testName}_bar_typescript_config.json`);
      fs.writeFileSync(configPath, JSON.stringify(plotlyConfig, null, 2));
      result.configPath = configPath;
      result.typescriptConfigSaved = true;

      console.log(`   💾 TypeScript config saved: ${configPath}`);

      result.success = true;

    } catch (error) {
      result.error = error instanceof Error ? error.message : String(error);
      console.log(`   ❌ TypeScript generation failed: ${result.error}`);
    }

    return result;
  }

  /**
   * Test TypeScript chart generation
   */
  async testTypeScriptChart(testName: string, data: any, chartOptions: any = {}): Promise<TestResult> {
    console.log(`\n🧪 Testing TypeScript chart: ${testName}`);

    const result: TestResult = {
      testName,
      success: false,
      configGenerated: false,
      pythonImageSaved: false,
      typescriptConfigSaved: false
    };

    try {
      // Create DataFrame
      const df = new DataFrame(data);
      console.log(`   📊 DataFrame created: ${df.shape[0]} rows × ${df.shape[1]} columns`);

      // Determine chart configuration
      const columns = df.columns;
      const xColumn = this.detectXColumn(columns, data);
      const yColumns = this.detectYColumns(columns, data, xColumn);
      
      console.log(`   📈 Chart config: x='${xColumn}', y=[${yColumns.join(', ')}]`);

      // Create scatter chart
      const chart = new ScatterChart({
        dataframe: df,
        xColumn,
        yColumns,
        colorColumn: this.detectColorColumn(columns, data)
      }, {
        title: `BWR Test Plot - ${testName}`,
        subtitle: 'Generated by TypeScript Implementation',
        ...chartOptions
      });

      // Validate chart
      if (!chart.isValid()) {
        throw new Error(`Chart validation failed: ${chart.getValidationErrors().join(', ')}`);
      }

      // Generate Plotly configuration
      const plotlyConfig = chart.render();
      result.configGenerated = true;

      console.log(`   ✅ Plotly config generated: ${JSON.stringify(plotlyConfig).length} characters`);

      // Save TypeScript configuration
      const configPath = path.join(this.outputDir, `${testName}_typescript_config.json`);
      fs.writeFileSync(configPath, JSON.stringify(plotlyConfig, null, 2));
      result.configPath = configPath;
      result.typescriptConfigSaved = true;

      console.log(`   💾 TypeScript config saved: ${configPath}`);

      result.success = true;

    } catch (error) {
      result.error = error instanceof Error ? error.message : String(error);
      console.log(`   ❌ TypeScript generation failed: ${result.error}`);
    }

    return result;
  }

  /**
   * Test Python chart generation via server
   */
  async testPythonChart(testName: string, data: any): Promise<TestResult> {
    console.log(`\n🐍 Testing Python chart: ${testName}`);

    const result: TestResult = {
      testName: testName + '_python',
      success: false,
      configGenerated: false,
      pythonImageSaved: false,
      typescriptConfigSaved: false
    };

    try {
      // Check if Python server is available
      const healthResponse = await fetch(`${this.serverUrl}/health`);
      if (!healthResponse.ok) {
        throw new Error('Python server not available');
      }

      // Prepare request data
      const requestData = {
        type: 'scatter',
        data: data,
        config: {
          title: `BWR Test Plot - ${testName}`,
          subtitle: 'Generated by Python Implementation'
        }
      };

      // Generate plot via Python server
      const response = await fetch(`${this.serverUrl}/generate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestData)
      });

      if (!response.ok) {
        throw new Error(`Python server responded with ${response.status}`);
      }

      const pythonResult = await response.json();

      if (!pythonResult.success) {
        throw new Error(`Python generation failed: ${pythonResult.error}`);
      }

      console.log(`   📊 Python plot generated: ${pythonResult.data_shape} shape`);
      console.log(`   🖼️  Image size: ${pythonResult.image?.length || 0} characters (base64)`);

      // Save Python image
      if (pythonResult.image) {
        const imagePath = path.join(this.outputDir, `${testName}_python.png`);
        const imageBuffer = Buffer.from(pythonResult.image, 'base64');
        fs.writeFileSync(imagePath, imageBuffer);
        result.imagePath = imagePath;
        result.pythonImageSaved = true;

        console.log(`   💾 Python image saved: ${imagePath}`);
      }

      // Save Python Plotly config
      if (pythonResult.plotly_json) {
        const configPath = path.join(this.outputDir, `${testName}_python_config.json`);
        fs.writeFileSync(configPath, pythonResult.plotly_json);
        result.configPath = configPath;
        result.configGenerated = true;

        console.log(`   💾 Python config saved: ${configPath}`);
      }

      result.success = true;

    } catch (error) {
      result.error = error instanceof Error ? error.message : String(error);
      console.log(`   ❌ Python generation failed: ${result.error}`);
    }

    return result;
  }

  /**
   * Run comprehensive test suite
   */
  async runTestSuite(): Promise<void> {
    console.log('🚀 BWR Plot Generation Test Suite');
    console.log('='.repeat(50));

    const results: TestResult[] = [];

    // Test each dataset
    for (const [testName, data] of Object.entries(TEST_DATA)) {
      try {
        // Test TypeScript implementation for appropriate chart types
        if (['categories', 'performance'].includes(testName)) {
          // Test bar charts for categorical data
          const barResult = await this.testTypeScriptBarChart(testName, data);
          results.push(barResult);

          // Test horizontal bar chart
          const horizontalBarResult = await this.testTypeScriptBarChart(
            testName + '_horizontal',
            data,
            { orientation: 'horizontal' }
          );
          results.push(horizontalBarResult);

          // Test sorted bar chart for performance data
          if (testName === 'performance') {
            const sortedBarResult = await this.testTypeScriptBarChart(
              testName + '_sorted',
              data,
              { sortBars: 'descending', showValues: true }
            );
            results.push(sortedBarResult);
          }

        } else {
          // Test scatter charts for continuous data
          const tsResult = await this.testTypeScriptChart(testName, data);
          results.push(tsResult);

          // Test Python implementation for scatter plots
          const pyResult = await this.testPythonChart(testName, data);
          results.push(pyResult);

          // Add special dual-axis test for financial data
          if (testName === 'financial') {
            const dualAxisResult = await this.testTypeScriptChart(
              testName + '_dual_axis',
              data,
              { enableDualAxis: true, y2Columns: ['volume'] }
            );
            results.push(dualAxisResult);
          }
        }

      } catch (error) {
        console.log(`   💥 Test suite error for ${testName}:`, error);
      }
    }

    // Generate summary
    this.generateTestSummary(results);
  }

  /**
   * Generate test summary report
   */
  private generateTestSummary(results: TestResult[]): void {
    console.log('\n📊 Test Summary Report');
    console.log('='.repeat(50));

    const successful = results.filter(r => r.success);
    const failed = results.filter(r => !r.success);

    console.log(`✅ Successful tests: ${successful.length}/${results.length}`);
    console.log(`❌ Failed tests: ${failed.length}/${results.length}`);

    if (successful.length > 0) {
      console.log('\n🎉 Successful Tests:');
      successful.forEach(result => {
        console.log(`   ✅ ${result.testName}`);
        if (result.imagePath) {
          console.log(`      📷 Image: ${path.basename(result.imagePath)}`);
        }
        if (result.configPath) {
          console.log(`      ⚙️  Config: ${path.basename(result.configPath)}`);
        }
      });
    }

    if (failed.length > 0) {
      console.log('\n💥 Failed Tests:');
      failed.forEach(result => {
        console.log(`   ❌ ${result.testName}: ${result.error}`);
      });
    }

    // Generate summary file
    const summaryPath = path.join(this.outputDir, 'test_summary.json');
    const summary = {
      timestamp: new Date().toISOString(),
      total: results.length,
      successful: successful.length,
      failed: failed.length,
      results: results.map(r => ({
        testName: r.testName,
        success: r.success,
        error: r.error,
        files: {
          image: r.imagePath ? path.basename(r.imagePath) : null,
          config: r.configPath ? path.basename(r.configPath) : null
        }
      }))
    };

    fs.writeFileSync(summaryPath, JSON.stringify(summary, null, 2));
    console.log(`\n📄 Summary saved: ${summaryPath}`);

    // List all generated files
    const files = fs.readdirSync(this.outputDir);
    console.log(`\n📁 Generated ${files.length} files in ${this.outputDir}:`);
    files.forEach(file => {
      const filePath = path.join(this.outputDir, file);
      const stats = fs.statSync(filePath);
      const size = this.formatFileSize(stats.size);
      console.log(`   📄 ${file} (${size})`);
    });
  }

  /**
   * Helper methods for chart configuration detection
   */
  private detectXColumn(columns: string[], data: any): string {
    // Look for common X column patterns
    const xPatterns = ['x', 'date', 'time', 'timestamp'];
    for (const pattern of xPatterns) {
      if (columns.includes(pattern)) return pattern;
    }
    // Default to first column
    return columns[0];
  }

  private detectYColumns(columns: string[], data: any, xColumn: string): string[] {
    // Get all numeric-looking columns except the X column
    const yColumns = columns.filter(col => {
      if (col === xColumn) return false;
      if (col === 'category' || col === 'size') return false;
      
      // Check if values look numeric
      const values = data[col];
      if (!Array.isArray(values)) return false;
      return values.every((val: any) => typeof val === 'number' && !isNaN(val));
    });

    // Return at least one Y column
    return yColumns.length > 0 ? yColumns.slice(0, 2) : [columns[1] || columns[0]];
  }

  private detectColorColumn(columns: string[], data: any): string | undefined {
    // Look for categorical columns
    const categoricalPatterns = ['category', 'type', 'group', 'label'];
    for (const pattern of categoricalPatterns) {
      if (columns.includes(pattern)) return pattern;
    }
    return undefined;
  }

  private detectCategoryColumn(columns: string[], data: any): string {
    // Look for common category column patterns
    const categoryPatterns = ['category', 'company', 'name', 'type', 'group'];
    for (const pattern of categoryPatterns) {
      if (columns.includes(pattern)) return pattern;
    }
    
    // Find first string column
    for (const col of columns) {
      const values = data[col];
      if (Array.isArray(values) && values.some(val => typeof val === 'string')) {
        return col;
      }
    }
    
    // Default to first column
    return columns[0];
  }

  private detectValueColumns(columns: string[], data: any, categoryColumn: string): string[] {
    // Get all numeric columns except the category column
    const valueColumns = columns.filter(col => {
      if (col === categoryColumn) return false;
      
      // Check if values look numeric
      const values = data[col];
      if (!Array.isArray(values)) return false;
      return values.every((val: any) => typeof val === 'number' && !isNaN(val));
    });

    // Return at least one value column
    return valueColumns.length > 0 ? valueColumns.slice(0, 2) : [columns[1] || columns[0]];
  }

  private formatFileSize(bytes: number): string {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;
  }
}

// Main execution
async function main() {
  const tester = new BWRPlotTester();
  
  try {
    await tester.runTestSuite();
    console.log('\n🎯 Test suite completed successfully!');
    process.exit(0);
  } catch (error) {
    console.error('\n💥 Test suite failed:', error);
    process.exit(1);
  }
}

// Run if this file is executed directly
if (require.main === module) {
  main().catch(error => {
    console.error('Fatal error:', error);
    process.exit(1);
  });
}

export { BWRPlotTester, TEST_DATA };